// Generated by CoffeeScript 1.9.3
(function() {
  var Bus, C, Car, Graphics, Truck, Vehicle, cells, clone, dec, draw, drawRoad, drawTick, getBehindVehicle, getFrontVehicle, getGap, getLeftBehindGap, getLeftFrontGap, getRightBehindGap, getRightFrontGap, graphics, inc, init, laneChange, move, random, renderer, returnBehindGap, returnFrontGap, simulate, stage, vehicles,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  C = {
    vehicles: {
      car: {
        size: 1,
        maxSpeed: 6,
        color: 0xFF0000
      },
      bus: {
        size: 2,
        maxSpeed: 5,
        color: 0x00FF00
      },
      truck: {
        size: 2,
        maxSpeed: 3,
        color: 0x0000FF
      }
    },
    pSlow: 0,
    numLanes: 5,
    numCells: 200,
    numVehicles: 200,
    sightCells: 10,
    rowMargin: 20,
    pxCellWidth: 18,
    pxCellHeight: 12,
    ticksPerSimulation: 60
  };

  C.rowHeight = C.pxCellHeight * C.numLanes;

  C.numRows = Math.ceil(C.numCells / C.cellsPerLane);

  C.width = C.numCells * C.pxCellWidth;

  C.height = C.rowHeight;

  Vehicle = (function() {
    function Vehicle(lane1, cell1, speed) {
      this.lane = lane1;
      this.cell = cell1;
      this.speed = speed;
    }

    return Vehicle;

  })();

  Car = (function(superClass) {
    extend(Car, superClass);

    function Car() {
      return Car.__super__.constructor.apply(this, arguments);
    }

    Car.prototype.size = C.vehicles.car.size;

    Car.prototype.maxSpeed = C.vehicles.car.maxSpeed;

    return Car;

  })(Vehicle);

  Bus = (function(superClass) {
    extend(Bus, superClass);

    function Bus() {
      return Bus.__super__.constructor.apply(this, arguments);
    }

    Bus.prototype.size = C.vehicles.bus.size;

    Bus.prototype.maxSpeed = C.vehicles.bus.maxSpeed;

    return Bus;

  })(Vehicle);

  Truck = (function(superClass) {
    extend(Truck, superClass);

    function Truck() {
      return Truck.__super__.constructor.apply(this, arguments);
    }

    Truck.prototype.size = C.vehicles.truck.size;

    Truck.prototype.maxSpeed = C.vehicles.truck.maxSpeed;

    return Truck;

  })(Vehicle);

  Graphics = (function() {
    function Graphics(lane1, cell1, color, size, index) {
      this.lane = lane1;
      this.cell = cell1;
      this.color = color;
      this.size = size;
      this.index = index;
      this.graphics = new PIXI.Graphics();
      this.graphics.lineStyle(1, 0x000000, 0.7);
      this.graphics.beginFill(this.color, 0.7);
      this.graphics.drawRect(0, 0, C.pxCellWidth * this.size, C.pxCellHeight);
      this.graphics.endFill();
      this.graphics.interactive = true;
      this.graphics.on('mousedown', (function(_this) {
        return function(e) {
          return console.log(_this.index, vehicles[_this.index]);
        };
      })(this));
      this.oldx = this.oldy = this.newx = this.newy = 0;
      this.setNewPosition(this.lane, this.cell);
      this.setNewPosition(this.lane, this.cell);
    }

    Graphics.prototype.setNewPosition = function(lane1, cell1) {
      var rlane;
      this.lane = lane1;
      this.cell = cell1;
      rlane = C.numLanes - this.lane - 1;
      this.oldx = this.newx;
      this.oldy = this.newy;
      this.newx = this.cell * C.pxCellWidth + C.pxCellWidth / 2;
      this.newy = rlane * C.pxCellHeight;
      if (this.newx < this.oldx) {
        this.oldx = this.newx;
        return this.oldy = this.newy;
      }
    };

    Graphics.prototype.update = function(drawTick) {
      var dx, dy;
      dx = (this.newx - this.oldx) / C.ticksPerSimulation;
      dy = (this.newy - this.oldy) / C.ticksPerSimulation;
      this.graphics.x = this.oldx + dx * drawTick;
      return this.graphics.y = this.oldy + dy * drawTick;
    };

    return Graphics;

  })();

  vehicles = null;

  graphics = null;

  cells = null;

  renderer = null;

  stage = null;

  move = function(vehicle) {
    var fve, gap, relv, v;
    v = vehicle.speed;
    if (v < vehicle.maxSpeed) {
      v = v + 1;
    }
    if (v > 3 && Math.random() < C.pSlow) {
      v = v - 1;
    }
    fve = getFrontVehicle(vehicle.lane, vehicle.cell + vehicle.size);
    gap = fve ? fve.cell - vehicle.cell - vehicle.size : Infinity;
    relv = fve ? v - 3 : 0;
    if (gap < relv) {
      v = gap + 3;
    }
    vehicle.cell = inc(vehicle.cell, v);
    return vehicle.speed = v;
  };

  laneChange = function(vehicle) {
    var fgap, lbgap, lfgap, rbgap, rfgap;
    if (vehicle.lane < C.numLanes - 1 && vehicle.speed < vehicle.maxSpeed) {
      fgap = getGap(vehicle);
      lfgap = getLeftFrontGap(vehicle);
      lbgap = getLeftBehindGap(vehicle);
      if (fgap.gap < vehicle.maxSpeed && lbgap.gap > lbgap.relv && lfgap.gap > lfgap.relv) {
        return +1;
      }
    }
    if (vehicle.lane > 0) {
      rfgap = getRightFrontGap(vehicle);
      rbgap = getRightBehindGap(vehicle);
      if (rfgap.gap > rfgap.relv && rbgap.gap > rbgap.relv) {
        return -1;
      }
    }
    return 0;
  };

  simulate = function() {
    var i, k, laneChanges, len, m, n, newv, now, o, old, p, ref, ref1, ref2, ref3, v;
    laneChanges = (function() {
      var k, len, results;
      results = [];
      for (k = 0, len = vehicles.length; k < len; k++) {
        v = vehicles[k];
        results.push(laneChange(v));
      }
      return results;
    })();
    for (i = k = 0, ref = C.numVehicles - 1; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {
      old = vehicles[i];
      cells[old.lane][old.cell] = null;
    }
    for (i = m = 0, ref1 = C.numVehicles - 1; 0 <= ref1 ? m <= ref1 : m >= ref1; i = 0 <= ref1 ? ++m : --m) {
      now = vehicles[i];
      now.lane += laneChanges[i];
      cells[now.lane][now.cell] = now;
    }
    newv = clone(vehicles);
    for (n = 0, len = newv.length; n < len; n++) {
      now = newv[n];
      move(now);
    }
    for (i = o = 0, ref2 = C.numVehicles - 1; 0 <= ref2 ? o <= ref2 : o >= ref2; i = 0 <= ref2 ? ++o : --o) {
      old = vehicles[i];
      cells[old.lane][old.cell] = null;
    }
    for (i = p = 0, ref3 = C.numVehicles - 1; 0 <= ref3 ? p <= ref3 : p >= ref3; i = 0 <= ref3 ? ++p : --p) {
      now = newv[i];
      cells[now.lane][now.cell] = now;
    }
    return vehicles = newv;
  };

  getFrontVehicle = function(lane, cell) {
    var j, step;
    j = cell;
    step = 0;
    while (step < C.sightCells && j < C.numCells && !cells[lane][j]) {
      ++step;
      ++j;
    }
    return cells[lane][j];
  };

  getBehindVehicle = function(lane, cell) {
    var j, step;
    j = cell;
    step = 0;
    while (step < C.sightCells && j >= 0 && !cells[lane][j]) {
      ++step;
      --j;
    }
    return cells[lane][j];
  };

  returnFrontGap = function(vehicle, v) {
    if (v) {
      return {
        gap: v.cell - vehicle.cell - vehicle.size,
        relv: vehicle.speed - v.speed
      };
    } else {
      return {
        gap: Infinity,
        relv: 0
      };
    }
  };

  returnBehindGap = function(vehicle, v) {
    if (v) {
      return {
        gap: vehicle.cell - v.cell - v.size,
        relv: v.speed - vehicle.speed
      };
    } else {
      return {
        gap: Infinity,
        relv: 0
      };
    }
  };

  getGap = function(vehicle) {
    var v;
    v = getFrontVehicle(vehicle.lane, vehicle.cell + vehicle.size);
    return returnFrontGap(vehicle, v);
  };

  getLeftFrontGap = function(vehicle) {
    var v;
    v = getFrontVehicle(vehicle.lane + 1, vehicle.cell);
    return returnFrontGap(vehicle, v);
  };

  getRightFrontGap = function(vehicle) {
    var v;
    v = getFrontVehicle(vehicle.lane - 1, vehicle.cell);
    return returnFrontGap(vehicle, v);
  };

  getLeftBehindGap = function(vehicle) {
    var v;
    v = getBehindVehicle(vehicle.lane + 1, vehicle.cell);
    return returnBehindGap(vehicle, v);
  };

  getRightBehindGap = function(vehicle) {
    var v;
    v = getBehindVehicle(vehicle.lane - 1, vehicle.cell);
    return returnBehindGap(vehicle, v);
  };

  random = function(hi) {
    return Math.floor(Math.random() * hi);
  };

  inc = function(x, y) {
    if (y == null) {
      y = 1;
    }
    if (x + y < C.numCells) {
      return x + y;
    } else {
      return x + y - C.numCells;
    }
  };

  dec = function(x, y) {
    if (y == null) {
      y = 1;
    }
    if (x - y >= 0) {
      return x - y;
    } else {
      return x - y + C.numCells;
    }
  };

  drawRoad = function() {
    var dashInterval, g, k, lane, m, ref, ref1, ref2, road_renderer, road_stage, x, y;
    road_renderer = new PIXI.autoDetectRenderer(C.width, C.height);
    road_stage = new PIXI.Container();
    road_renderer.backgroundColor = 0xFFFFFF;
    document.getElementById('road').appendChild(road_renderer.view);
    g = new PIXI.Graphics();
    dashInterval = C.pxCellWidth;
    g.lineStyle(2, 0x000000, 1);
    g.drawRect(0, 0, C.width, C.rowHeight);
    g.endFill();
    y = 0;
    for (lane = k = 0, ref = C.numLanes - 1; 0 <= ref ? k <= ref : k >= ref; lane = 0 <= ref ? ++k : --k) {
      g.lineStyle(1, 0x000000, 1);
      for (x = m = 0, ref1 = C.width - dashInterval, ref2 = dashInterval * 2; ref2 > 0 ? m <= ref1 : m >= ref1; x = m += ref2) {
        g.moveTo(x, y);
        g.lineTo(x + dashInterval, y);
      }
      g.endFill();
      y += C.pxCellHeight;
    }
    road_stage.addChild(g);
    return road_renderer.render(road_stage);
  };

  init = function() {
    var g, i, j, k, l, m, n, now, rand, ref, ref1, ref2, step, t, v, x, y, y2;
    vehicles = [];
    graphics = [];
    cells = [];
    renderer = new PIXI.autoDetectRenderer(C.width, C.height, {
      transparent: true
    });
    stage = new PIXI.Container();
    document.getElementById('vehicle').appendChild(renderer.view);
    for (i = k = 0, ref = C.numLanes - 1; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {
      cells.push([]);
      for (j = m = 0, ref1 = C.numCells - 1; 0 <= ref1 ? m <= ref1 : m >= ref1; j = 0 <= ref1 ? ++m : --m) {
        cells[i].push(null);
      }
    }
    for (i = n = 0, ref2 = C.numVehicles - 1; 0 <= ref2 ? n <= ref2 : n >= ref2; i = 0 <= ref2 ? ++n : --n) {
      x = y = v = t = now = null;
      while (true) {
        x = random(C.numLanes);
        y = random(C.numCells);
        rand = Math.random();
        if (rand < .1) {
          t = "truck";
        } else if (rand < .4) {
          t = "bus";
        } else {
          t = "car";
        }
        v = random(C.vehicles[t].maxSpeed - 3) + 3;
        l = C.vehicles[t].size;
        y2 = y;
        step = 0;
        while (step < l && !cells[x][y2]) {
          ++step;
          y2 = inc(y2);
        }
        if (step === l) {
          break;
        }
      }
      switch (t) {
        case "car":
          now = new Car(x, y, v);
          break;
        case "bus":
          now = new Bus(x, y, v);
          break;
        case "truck":
          now = new Truck(x, y, v);
      }
      vehicles.push(now);
      cells[x][y] = now;
      g = new Graphics(x, y, C.vehicles[t].color, now.size, i);
      graphics.push(g);
      stage.addChild(g.graphics);
    }
    drawRoad();
    return draw();
  };

  drawTick = 0;

  draw = function() {
    var g, i, k, len, m, ref, v;
    requestAnimationFrame(draw);
    ++drawTick;
    if (drawTick === C.ticksPerSimulation) {
      drawTick = 0;
      simulate();
      for (i = k = 0, ref = C.numVehicles - 1; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {
        v = vehicles[i];
        g = graphics[i];
        g.setNewPosition(v.lane, v.cell);
      }
    }
    for (m = 0, len = graphics.length; m < len; m++) {
      g = graphics[m];
      g.update(drawTick);
    }
    return renderer.render(stage);
  };

  clone = function(obj) {
    var key, temp;
    if (obj === null || typeof obj !== "object") {
      return obj;
    }
    temp = new obj.constructor();
    for (key in obj) {
      temp[key] = clone(obj[key]);
    }
    return temp;
  };

  init();

}).call(this);
